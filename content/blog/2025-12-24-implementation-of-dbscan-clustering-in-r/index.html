---
title: Implementation of DBSCAN Clustering in R
author: Jose M Sallan
date: '2025-12-24'
slug: implementation-of-dbscan-clustering-in-r
categories:
  - R
tags:
  - clustering
meta_img: images/image.png
description: Description for the page
---



<p><strong>Cluster analysis</strong>, or <strong>clustering</strong>, consists of partitioning a set of objects into groups such that objects within the same group (called a cluster) exhibit greater similarity to one another (in some specific sense defined by the analyst) than to those in other clusters.</p>
<p>In this post, I will introduce a clustering technique called <strong>discrete-based spatial clustering and applications with noise (DBSCAN)</strong> introduced in Ester et al. (1996). In R, this technique is implemented with the <code>dbscan</code> package. In this post I will introduce DBSCAN, its specific approach to clustering and how to perform DBSCAN clustering in R.</p>
<pre class="r"><code>library(tidyverse)
library(broom)
library(dbscan)
library(patchwork)</code></pre>
<p>There are two traditional types of clustering algorithms: partitioning and hierarchical algorithms. <strong>Partitioning</strong> algorithms obtain a partition of the dataset into <em>k</em> clusters, so that the within-clusters square distances are smaller than between-clusters. The best known of these algorithms is k-means. These algorithms generate clusters that tend to be spherical and compact around a cluster center. <strong>Hierarchical</strong> algorithms create a hierarchical decomposition of the dataset, graphically represented with a dendogram. These techniques are implemented in R base with functions like <code>kmeans()</code> and <code>hclust()</code>.</p>
<p>These algorithms are not effective to identify clusters defined as subsets of elements with a higher density within the cluster than outside the cluster and with irregular shapes. Two examples are the <code>two_moons</code> and <code>target</code> datasets, obtained with functions of the <code>fdm2id</code> package.</p>
<pre class="r"><code>set.seed(1111)
two_moons &lt;- fdm2id::data.twomoons(sigma = 0.1, graph = FALSE)
target &lt;- fdm2id::data.target2(initn = 600, graph = FALSE)</code></pre>
<p>These datasets have two distinct clusters of irregular shape. Let’s try to detect them using <code>kmeans()</code>. I am using <code>broom::augment()</code> to add the <code>.cluster</code> column to the original dataset.</p>
<pre class="r"><code>set.seed(1111)
two_moons_km &lt;- kmeans(two_moons[, 1:2], centers = 2)
target_km &lt;- kmeans(target[, 1:2], centers = 2)

two_moons_km_table &lt;- augment(two_moons_km, data = two_moons)
target_km_table &lt;- augment(target_km, data = target)</code></pre>
<p>Let’s see how <code>kmeans()</code> is performing:</p>
<pre class="r"><code>p1 &lt;- ggplot(two_moons_km_table, aes(X, Y, color = .cluster)) +
  geom_point() +
  labs(title = &quot;Two Moons (k-means)&quot;, x = NULL, y = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = &quot;bottom&quot;)

p2 &lt;- ggplot(target_km_table, aes(X, Y, color = .cluster)) +
  geom_point() +
  labs(title = &quot;Target (k-means)&quot;, x = NULL, y = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = &quot;bottom&quot;)

p1 + p2</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-5-1.png" width="100%" /></p>
<p>As we can see, k-means is performing poorly on these datasets.</p>
<div id="the-dbscan-algorithm" class="section level2">
<h2>The DBSCAN Algorithm</h2>
<p>The DBSCAN algorithm takes a density-based approach to clustering. The algorithm is based on two parameters:</p>
<ul>
<li>The maximum distance between cluster points. It is the <code>eps</code> argument of the <code>dbscan()</code> function.</li>
<li>The minimum number of points close to a core point of the cluster. It is the <code>minPts</code> argument of the <code>dbscan()</code> function.</li>
</ul>
<p>Taking this into account, we can make the following definitions:</p>
<ul>
<li>An element <span class="math inline">\(p\)</span> of the dataset is a <strong>core</strong> point if there are at least <code>minPts</code> elements within a distance equal or smaller than <code>eps</code> from it.</li>
<li>An element <span class="math inline">\(q\)</span> is <strong>directly reachable</strong> from <span class="math inline">\(p\)</span> if it is within a distance equal or smaller than <code>eps</code> from <span class="math inline">\(p\)</span>.</li>
<li><span class="math inline">\(q\)</span> is <strong>density-reachable</strong> from <span class="math inline">\(p\)</span> if there is a path starting at <span class="math inline">\(p\)</span> and ending at <span class="math inline">\(q\)</span> where each element <span class="math inline">\(p_{i+1}\)</span> is directly reachable from <span class="math inline">\(p_i\)</span>. All points of the path must be core points with the probable exception of <span class="math inline">\(q\)</span>.</li>
<li>Two points <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are <strong>density-connected</strong> if there is a point <span class="math inline">\(o\)</span> such that <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are reachable from <span class="math inline">\(o\)</span>.</li>
<li>A point is a <strong>noise</strong> point if it is not reachable from any other points. These points are not assigned to any cluster by the algorithm.</li>
</ul>
<p>DBSCAN clusters are formed as sets of density-connected points. The points of a cluster that are not core points are <strong>border</strong> points.</p>
<p>Regarding parameter estimates, <code>minPts</code> is usually set as the dimensions of the dataset plus one. For <code>minPts = 2</code>, the result is similar to a hierachical clustering with the dendogram cut at height <code>eps</code>.</p>
<p>DBSCAN has some relevant differences from other clustering methods:</p>
<ul>
<li>The <strong>number of clusters</strong> is not fixed beforehand. Typically small values of <code>eps</code> lead to many small clusters, and large values of <code>eps</code> lead to few large clusters.</li>
<li>There may be <strong>noise points</strong> that do not belong to any cluster.</li>
</ul>
<p>As the connectivity between points is based on paths of connected core points rather than the distance from a center point, this algorithm can be adequate to detect clusters of irregular shapes of spatial datasets.</p>
</div>
<div id="a-small-example" class="section level2">
<h2>A Small Example</h2>
<p>Let’s start with a small example consisting of a two dimensional dataset of twenty points.</p>
<pre class="r"><code>x &lt;- c(4, 6, 5, 5, 5, 6, 7, 2, 11, 12, 13, 12, 12, 13, 14, 12, 10, 15, 4, 13)
y &lt;- c(6, 6, 7, 5, 4, 4, 4, 6, 10, 11, 10, 9, 8, 8, 8, 6, 8, 10, 13, 3)

points &lt;- tibble(point = 1:20, x = x, y = y)

ggplot(points, aes(x, y, label = point)) +
  geom_label() +
  theme_minimal() +
  scale_x_continuous(breaks = 1:20) +
  scale_y_continuous(breaks = 1:20) </code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-6-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>By ocular inspection, we can see two clusters: one of points 1 to 8, and other with points 9 to 18. Points 19 and 20 can be considered noise points.</p>
<p>Let’s consider for this example <code>eps = 3</code> and <code>minPts = 3</code>. The <code>m_points</code> table includes all pairs of elements with a distance equal or smaller than three.</p>
<pre class="r"><code>m_points &lt;- dist(points[, 2:3]) |&gt;
  as.matrix() |&gt;
  as.data.frame() |&gt;
  mutate(row = 1:n()) |&gt;
  pivot_longer(-row, names_to = &quot;col&quot;, values_to = &quot;dist&quot;) |&gt;
  mutate(col = as.numeric(col)) |&gt;
  filter(row != col)</code></pre>
<p>With this table, we can detect the core points as those with at least <code>minPts</code> elements at a distance equal or smaller than <code>eps</code>.</p>
<pre class="r"><code>eps &lt;- 3
minPts &lt;- 3

core &lt;- m_points |&gt;
  filter(dist &lt;= eps) |&gt;
  group_by(row) |&gt;
  summarise(n = n(), .groups = &quot;drop&quot;) |&gt;
  filter(n &gt;= minPts) |&gt;
  pull(row)

core</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  9 10 11 12 13 14 15 16 17 18</code></pre>
<p>The core elements are points 1 to 18 except point 8. Let’s identify the border points, that is, density reachable points that are not core points.</p>
<pre class="r"><code>reached &lt;- m_points |&gt;
  filter(dist &lt;= eps) |&gt;
  filter(row %in% core) |&gt;
  pull(col) |&gt;
  unique()

reachable &lt;- reached[!reached %in% core]
reachable</code></pre>
<pre><code>## [1] 8</code></pre>
<p>The only border point for this dataset is 8. Let’s see from where it is reached:</p>
<pre class="r"><code>m_points |&gt;
  filter(row == 8, dist &lt;= eps)</code></pre>
<pre><code>## # A tibble: 1 × 3
##     row   col  dist
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     8     1     2</code></pre>
<p>Element 8 is only reached by element 1, so it is not a core element. Let’s see another possible peripheral element like 18:</p>
<pre class="r"><code>m_points |&gt;
  filter(row == 18, dist &lt;= eps)</code></pre>
<pre><code>## # A tibble: 3 × 3
##     row   col  dist
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1    18    11  2   
## 2    18    14  2.83
## 3    18    15  2.24</code></pre>
<p>As 18 has three elements with a distance equal or smaller than <code>eps</code>, it is a core element.</p>
<p>The rest of elements are the noise points:</p>
<pre class="r"><code>labels &lt;- 1:20
noise &lt;- labels[!labels %in% c(core, reachable)]
noise</code></pre>
<pre><code>## [1] 19 20</code></pre>
<p>The DBSCAN clustering of this dataset would be:</p>
<pre class="r"><code>example_db &lt;- dbscan(points[, 2:3], eps = 3, minPts = 3)
example_db$cluster</code></pre>
<pre><code>##  [1] 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 0 0</code></pre>
<p>Here is a representation of the clustering, indicating core, border and noise points.</p>
<pre class="r"><code>type &lt;- character(20)
type[core[1:7]] &lt;- &quot;c1_core&quot;
type[core[8:17]] &lt;- &quot;c2_core&quot;
type[reachable] &lt;- &quot;c1_border&quot;
type[noise] &lt;- &quot;noise&quot;

points &lt;- points |&gt;
  mutate(type = type)

ggplot(points, aes(x, y, label = point, fill = type)) +
  geom_label(alpha = 0.5) +
  theme_minimal(base_size = 12) +
  scale_x_continuous(breaks = 1:20, name = NULL) +
  scale_y_continuous(breaks = 1:20, name = NULL) +
  scale_fill_manual(values = c(&quot;#FF3333&quot;, &quot;#FF9933&quot;, &quot;#3399FF&quot;, &quot;#A0A0A0&quot;)) +
  theme(legend.position = &quot;bottom&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-14-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="testing-dbscan-on-spatial-datasets" class="section level2">
<h2>Testing DBSCAN on Spatial Datasets</h2>
<p>Let’s see how DBSCAN works in the <code>two_moons</code> and <code>target</code> datasets. I have set <code>minPts = 3</code> and found <code>eps</code> by trial and error. I have used <code>broom::augment()</code> to add the <code>.cluster</code> column.</p>
<pre class="r"><code>set.seed(1111)
two_moons_db &lt;- dbscan(two_moons[, 1:2], eps = 0.25, minPts = 3)
target_db &lt;- dbscan(target[, 1:2], eps = 0.5, minPts = 3)

two_moons_db_table &lt;- augment(two_moons_db, data = two_moons)
target_db_table &lt;- augment(target_db, data = target)</code></pre>
<p>Here is the graphical result:</p>
<pre class="r"><code>p1 &lt;- ggplot(two_moons_db_table, aes(X, Y, color = .cluster)) +
  geom_point() +
  labs(title = &quot;Two Moons (DBSCAN)&quot;, x = NULL, y = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = &quot;bottom&quot;)

p2 &lt;- ggplot(target_db_table, aes(X, Y, color = .cluster)) +
  geom_point() +
  labs(title = &quot;Target (DBSCAN)&quot;, x = NULL, y = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = &quot;bottom&quot;)

p1 + p2</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-16-1.png" width="100%" /></p>
<p>In both datasets, DBSCAN finds the two clusters of points as irregular, dense regions of points.</p>
</div>
<div id="the-dbscan-algorithm-1" class="section level2">
<h2>The DBSCAN algorithm</h2>
<p>DBSCAN is a clustering algorithm that detects clusters as sets of points within regions denser than in the rest of the space. The algorithm relies on two parameters: the maximum distance between points <code>eps</code> and the minimum number of points reached by a core point <code>minPts</code>. In two-dimensional datasets is usual to set <code>minPts = 3</code>. The value of <code>eps</code> depends on the distance scale, and can be adjusted by trial and error. Large values of <code>eps</code> will produce few, large clusters and small values of <code>eps</code> many, small clusters.</p>
<p>DBSCAN is implemented in R with the <code>dbscan</code> package. As with R base clustering functions like <code>kmeans()</code> and <code>hclust()</code>, we can use the broom functions to obtain the output of the algorithm.</p>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<ul>
<li>DBSCAN Wikipedia article: <a href="https://en.wikipedia.org/wiki/DBSCAN" class="uri">https://en.wikipedia.org/wiki/DBSCAN</a></li>
<li>Ester, Martin, Hans-Peter Kriegel, Jörg Sander, Xiaowei Xu, et al. (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. In <em>Proceedings of 2nd International Conference on Knowledge Discovery and Data Mining (KDD-96)</em>, 226–231. <a href="https://dl.acm.org/doi/10.5555/3001460.3001507" class="uri">https://dl.acm.org/doi/10.5555/3001460.3001507</a></li>
<li><code>fdm2id</code> package: <a href="https://cran.r-project.org/web/packages/fdm2id/refman/fdm2id.html" class="uri">https://cran.r-project.org/web/packages/fdm2id/refman/fdm2id.html</a></li>
</ul>
</div>
<div id="session-info" class="section level2">
<h2>Session Info</h2>
<p>The package <code>fdm2id</code> has not been loaded. The two datasets have been loaded from an <code>.rd</code> file.</p>
<pre><code>## R version 4.5.2 (2025-10-31)
## Platform: x86_64-pc-linux-gnu
## Running under: Linux Mint 21.1
## 
## Matrix products: default
## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 
## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0  LAPACK version 3.10.0
## 
## locale:
##  [1] LC_CTYPE=es_ES.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=es_ES.UTF-8        LC_COLLATE=es_ES.UTF-8    
##  [5] LC_MONETARY=es_ES.UTF-8    LC_MESSAGES=es_ES.UTF-8   
##  [7] LC_PAPER=es_ES.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=es_ES.UTF-8 LC_IDENTIFICATION=C       
## 
## time zone: Europe/Madrid
## tzcode source: system (glibc)
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] patchwork_1.3.0 dbscan_1.2.3    broom_1.0.10    lubridate_1.9.4
##  [5] forcats_1.0.1   stringr_1.6.0   dplyr_1.1.4     purrr_1.2.0    
##  [9] readr_2.1.5     tidyr_1.3.1     tibble_3.3.0    ggplot2_4.0.0  
## [13] tidyverse_2.0.0
## 
## loaded via a namespace (and not attached):
##  [1] gtable_0.3.6       jsonlite_2.0.0     compiler_4.5.2     Rcpp_1.1.0        
##  [5] tidyselect_1.2.1   jquerylib_0.1.4    scales_1.4.0       yaml_2.3.10       
##  [9] fastmap_1.2.0      R6_2.6.1           labeling_0.4.3     generics_0.1.3    
## [13] knitr_1.50         backports_1.5.0    bookdown_0.43      tzdb_0.5.0        
## [17] bslib_0.9.0        pillar_1.11.1      RColorBrewer_1.1-3 rlang_1.1.6       
## [21] stringi_1.8.7      cachem_1.1.0       xfun_0.52          sass_0.4.10       
## [25] S7_0.2.0           timechange_0.3.0   cli_3.6.4          withr_3.0.2       
## [29] magrittr_2.0.4     digest_0.6.37      grid_4.5.2         rstudioapi_0.17.1 
## [33] hms_1.1.4          lifecycle_1.0.4    vctrs_0.6.5        evaluate_1.0.3    
## [37] glue_1.8.0         farver_2.1.2       blogdown_1.21      rmarkdown_2.29    
## [41] tools_4.5.2        pkgconfig_2.0.3    htmltools_0.5.8.1</code></pre>
</div>
