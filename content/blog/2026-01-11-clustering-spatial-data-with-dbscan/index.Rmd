---
title: Clustering Spatial Data with DBSCAN
author: Jose M Sallan
date: '2026-01-11'
slug: []
categories:
  - R
  - data analysis
tags:
  - Barcelona
  - clustering
  - nightlife
meta_img: images/image.png
description: Description for the page
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In [a previous post]https://jmsallan.netlify.app/blog/implementation-of-dbscan-clustering-in-r/), I introduced a clustering technique called **discrete-based spatial clustering and applications with noise (DBSCAN)**. This clustering technique is density-based, detecting sets of elements located in a region of high density. This approach is different from traditional clustering techniques like k-means or hierarchical clustering. These techniques identify sets where the distance within elements is smaller than distance between elements of other clusters.

DBSCAN is a suitable technique for spatial analysis. While in distance-based techniques like k-means the regions defined by clusters tend to be circular, DBSCAN clusters can have any shape.

In this post, I will extend the DBSCAN workflow of previous posts in two directions:

- How to identify an adequate value of the distance between core points `eps` using the plot of **k-nearest neighbor distances**.
- How to use the functions of the `dbscan` package with spatial objects, using the distance matrix instead of geographical coordinates.

```{r, message=FALSE}
library(tidyverse) # data handling and plotting
library(sf) # geocomputation
library(BAdatasetsSpatial) # BCN map
library(dbscan) # DBSCAN clustering
library(RColorBrewer) # color palettes
```

```{r, echo=FALSE}
load("data/nightlife.rd")
data("BCNDistricts")
```

I will be using the dataset of nightlife Barcelona venues `nightlife_2024`, and its transformation as spatial object `nightlife_2024_sf`. To plot the final result, I will use the `bcn_neigh` Barcelona map of neighborhoods.

```{r}
bcn_neigh <- BCNNeigh |>
  select(c_barri, n_barri, c_distri, n_distri)
```

```{r}
nightlife_2024 <- data_2024 |>
  select(nom_local, latitud, longitud, nom_barri, codi_barri)

nightlife_2024_sf <- nightlife_2024 |>
  st_as_sf(coords = c("longitud", "latitud"), crs = 4326, remove = FALSE)
```

A common approach to cluster spatial data is use longitude and latitude directly, as they represent approximately the $x$ and $y$ coordinates of each point. But in DBSCAN the `eps` parameter is expressed in distance units, so we cannot use longitude and latitude directly. `dbscan::dbscan()` allows using a distance matrix rather than a set of coordinates. To obtain this distance, I have used the `sf::st_distance()` function and transformed the result to a distance object with `as.dist()`.

```{r}
nl_distances <- st_distance(nightlife_2024_sf) |>
  as.dist()
```

As it is two-dimensional dataset, I will use the standard value `minPts = 3`. We need, though, to establish an adequate value of maximum distance between contiguous core points `eps`. To do so, I have used the **k-nearest neighbor distances** plot. Obtained with `dbscan::kNNdistplot()`, it represents the distance between each element and its k-th distant neighbor. As `minPts` includes the point from we calculate distances, we need to set `k = minPts - 1`.

```{r, fig.align='center'}
kNNdistplot(nl_distances, k = 2)
abline(a = 400, b = 0, col = "red", lty = 2)
```

The choice of `eps` is the elbow point of this plot. In this case, I have chosen `eps = 450`. The results of the clustering are stored in `nl_dbscan`.

```{r}
nl_dbscan <- dbscan(nl_distances, eps = 450, minPts = 3)
table(nl_dbscan$cluster)
```

The algorithm returns eight different clusters and 13 noise points, not assigned to any cluster. These noise points are assigned to the `0` label.

```{r}
augment(nl_dbscan, nightlife_2024_sf) |>
  filter(noise) |>
  st_drop_geometry() |>
  select(nom_local, .cluster, noise)
```

To obtain a preliminary plot of the clusters, I have used `broom::augment()` to assign points to clusters.

```{r, fig.align='center'}
augment(nl_dbscan, nightlife_2024) |>
  ggplot(aes(longitud, latitud, color = .cluster)) +
  geom_point() +   
  theme_minimal(base_size = 14)
```

Finally, I can place clusters over a map. I need to take into account two issues:

- We cannot use `broom::augment()` with spatial objects, so I need to assign clusters with `dplyr::mutate()`.
- I have created a color palette `col_clust` using the divergent Brewer palette `Paired`, setting in grey the noise points.

```{r, fig.align='center', fig.height=7}
col_clust <- c("#A0A0A0", brewer.pal(8, "Paired"))

nl_dbscan_sf <- nightlife_2024_sf |>
  mutate(cluster = as.factor(nl_dbscan$cluster))

ggplot(bcn_neigh) +
  geom_sf(fill = "white") +
  geom_sf(data = nl_dbscan_sf, aes(color = cluster)) +
  scale_color_manual(values = col_clust) +
  theme_void() +
  theme(legend.position = "bottom")
```

Here is the result of the DBSCAN clustering:

- Two large clusters: cluster `2` corresponds with the city downtown, and `3` with the more residential districts of Gràcia and Sant Gervasi. 
- Three medium-size clusters. Cluster `6` is located at the northern neighborhoods, mainly El Guinardó. Cluster `8` includes venues around Poblenou. Cluster `1` includes venues at Sants and Badal. 
- Three small clusters, located at Eixample (cluster `4`), Vila Olímpica (cluster `7`) and Horta (cluster `5`).

## References

- Ester, Martin, Hans-Peter Kriegel, Jörg Sander, Xiaowei Xu, et al. (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. In *Proceedings of 2nd International Conference on Knowledge Discovery and Data Mining (KDD-96)*, 226–231. <https://dl.acm.org/doi/10.5555/3001460.3001507>
- Hahsler, M., Piekenbrock, M., & Doran, D. (2019). dbscan: Fast density-based clustering with R. *Journal of Statistical Software*, 91, 1-30. <https://doi.org/10.18637/jss.v091.i01>

## Session Info

```{r, echo=FALSE}
sessionInfo()
```



